using System.Collections.Concurrent;
using Open.Disposable;
using Open.Disposable.ObjectPools;

namespace Open.BlobStorageAdapter;

/// <summary>
/// Provides synchronized access to an underlying <see cref="IAsyncDictionary{TKey, TValue}"/>.
/// This wrapper ensures exclusive leased access to dictionary entries during operations,
/// preventing race conditions in multi-threaded environments.
/// </summary>
/// <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
/// <typeparam name="TValue">The type of values in the dictionary.</typeparam>
/// <remarks>
/// Initializes a new instance of the <see cref="SynchronizedAsyncDictionary{TKey, TValue}"/> class
/// that wraps the specified <see cref="IAsyncDictionary{TKey, TValue}"/> implementation.
/// </remarks>
/// <param name="innerDictionary">The underlying dictionary to provide synchronized access to.</param>
/// <param name="semaphorePool">The object pool for recycling SemaphoreSlim instances.</param>
public class SynchronizedAsyncDictionary<TKey, TValue>(
	IAsyncDictionary<TKey, TValue> innerDictionary,
	IObjectPool<SemaphoreSlim>? semaphorePool = null)
	: ISynchronizedAsyncDictionary<TKey, TValue>
	, IDisposable
	where TKey : notnull
{
	private readonly IAsyncDictionary<TKey, TValue> _innerDictionary
		= innerDictionary ?? throw new ArgumentNullException(nameof(innerDictionary));

	private readonly ConcurrentDictionary<TKey, Lazy<SemaphoreSlimLease>> _locks = new();
	private readonly IObjectPool<SemaphoreSlim> _semaphorePool;
	private int _disposeState;

	/// <summary>
	/// A recyclable lease for a SemaphoreSlim that can be returned to the pool when no longer needed.
	/// </summary>
	private class SemaphoreSlimLease : DisposableBase
	{
		/// <summary>
		/// The leased semaphore.
		/// </summary>
		public readonly SemaphoreSlim Semaphore;
		private readonly IObjectPool<SemaphoreSlim> _pool;

		public SemaphoreSlimLease(SemaphoreSlim semaphore, IObjectPool<SemaphoreSlim> pool)
		{
			Semaphore = semaphore;
			_pool = pool;
		}

		protected override void OnDispose()
		{
			if (Semaphore.CurrentCount == 0)
			{
				try { Semaphore.Release(); } catch { /* ignore */ }
			}
			
			_pool.Give(Semaphore);
		}
	}

	/// <summary>
	/// Initializes a new instance of the <see cref="SynchronizedAsyncDictionary{TKey, TValue}"/> class
	/// with the specified inner dictionary.
	/// </summary>
	static SynchronizedAsyncDictionary()
	{
		// Empty constructor needed for static initialization
	}

	/// <summary>
	/// Constructs a new <see cref="SynchronizedAsyncDictionary{TKey, TValue}"/> instance.
	/// </summary>
	public SynchronizedAsyncDictionary() : this(new MemoryAsyncDictionary<TKey, TValue>())
	{
		// Default constructor implementation
	}

	// Constructor logic for initializing semaphore pool
	{
		// Initialize default semaphore pool if not provided
		_semaphorePool = semaphorePool ?? RecyclableObjectPool<SemaphoreSlim>.Create(
			factory: () => new SemaphoreSlim(1, 1),
			recycler: semaphore =>
			{
				// Ensure the semaphore is in a released state before recycling
				if (semaphore.CurrentCount == 0)
				{
					try { semaphore.Release(); } catch { /* ignore */ }
				}
				
				return true; // Semaphore can be reused
			});
	}

	/// <inheritdoc />
	public ValueTask<bool> ExistsAsync(TKey key, CancellationToken cancellationToken)
		=> _innerDictionary.ExistsAsync(key, cancellationToken);

	/// <inheritdoc />
	public ValueTask<TryReadResult<TValue>> TryReadAsync(TKey key, CancellationToken cancellationToken)
		=> _innerDictionary.TryReadAsync(key, cancellationToken);

	/// <inheritdoc />
	/// <remarks>
	/// This implementation uses a <see cref="SemaphoreSlim"/> to ensure exclusive access to each key.
	/// The semaphore is automatically acquired before the operation and released after it completes,
	/// regardless of whether the operation succeeds or throws an exception. This creates an exclusive 
	/// lease on the entry for the duration of the operation, ensuring thread safety.
	/// </remarks>
	public async ValueTask<T> LeaseAsync<T>(
		TKey key,
		CancellationToken cancellationToken,
		Func<IAsyncDictionaryEntry<TKey, TValue>, CancellationToken, ValueTask<T>> operation)
	{
		if (_disposeState != 0)
			throw new ObjectDisposedException(nameof(SynchronizedAsyncDictionary<TKey, TValue>));

		cancellationToken.ThrowIfCancellationRequested();

		// Get or create a synchronization lock for this key
		var keyLockLazy = _locks.GetOrAdd(key, k => new Lazy<SemaphoreSlimLease>(() => 
			new SemaphoreSlimLease(_semaphorePool.Take(), _semaphorePool)));
		
		var keyLock = keyLockLazy.Value;

		try
		{
			// Wait for exclusive access to the key
			await keyLock.Semaphore.WaitAsync(cancellationToken).ConfigureAwait(false);

			try
			{
				// Get the dictionary entry from the inner dictionary and execute the operation with exclusive access
				var entry = _innerDictionary[key];
				return await operation(entry, cancellationToken).ConfigureAwait(false);
			}
			finally
			{
				// Release the lock
				keyLock.Semaphore.Release();
			}
		}
		finally
		{
			// If there are no pending operations and the key doesn't exist in the dictionary,
			// we can safely remove the lock from our locks dictionary
			if (keyLock.Semaphore.CurrentCount == 1 && 
				!await _innerDictionary.ExistsAsync(key, CancellationToken.None).ConfigureAwait(false))
			{
				// Try to remove the lock to prevent memory leaks
				if (_locks.TryRemove(key, out var removed))
				{
					removed.Value.Dispose();
				}
			}
		}
	}

	/// <summary>
	/// Disposes the synchronization resources used by this dictionary.
	/// </summary>
	/// <remarks>
	/// Releases all semaphores used for synchronizing access to dictionary entries.
	/// This does not dispose the underlying dictionary.
	/// </remarks>
	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}

	/// <summary>
	/// Disposes the synchronization resources used by this dictionary.
	/// </summary>
	/// <param name="disposing">Whether this is being called from the Dispose method.</param>
	protected virtual void Dispose(bool disposing)
	{
		if (Interlocked.CompareExchange(ref _disposeState, 1, 0) != 0)
			return;

		if (disposing)
		{
			foreach (var lockItem in _locks.Values)
			{
				if (lockItem.IsValueCreated)
				{
					lockItem.Value.Dispose();
				}
			}

			_locks.Clear();
		}

		Interlocked.CompareExchange(ref _disposeState, 2, 1);
	}
}
